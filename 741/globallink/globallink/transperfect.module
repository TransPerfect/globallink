<?php

define('TPT_ROOT', dirname(__FILE__));
require_once TPT_ROOT . '/' . ('transperfect.inc');
require_once TPT_ROOT . '/' . ('transperfect_receive_translations.inc');
require_once TPT_ROOT . '/' . ('transperfect_field_configuration.inc');

define('TPT_ROLE_MANAGE_TRANSLATIONS', t('can manage GlobalLink translation tasks and settings'));
define('TPT_ROLE_DO_TRANSALTIONS', t('can manage GlobalLink translation tasks'));
define('TPT_ROLE_VIEW_TRANSLATIONS', t('can view GlobalLink translation tasks'));

define('TPT_STATUS_PENDING_TRANSLATIONS', 'Pending Translations');
define('TPT_STATUS_SENT_FOR_TRANSLATIONS', 'Sent for Translations');
define('TPT_STATUS_PUBLISHED', 'Published');
define('TPT_STATUS_COMPLETED', 'Translation Completed');
define('TPT_STATUS_DELETED', 'Node Deleted');
define('TPT_STATUS_SOURCE_DELETED', 'Source Deleted');
define('TPT_STATUS_ERROR', 'Error');
define('TPT_STATUS_ARCHIVED', 'Archived');
define('TPT_STATUS_CANCELLED', 'Cancelled');

define('PD_STATUS_CANCELLED', 'CANCELLED');

define('TPT_LABEL_ACTIVE_SUBMISSION', t('Active Submission Name'));
define('TPT_LABEL_SUBMISSION', t('Submission'));
define('TPT_LABEL_CONTENT', t('Content'));
define('TPT_LABEL_CONTENT_TYPE', t('Content Type'));
define('TPT_LABEL_SOURCE_LANG', t('Source Language'));
define('TPT_LABEL_TARGET_LANG', t('Target Language'));
define('TPT_LABEL_STATUS', t('Status'));
define('TPT_LABEL_LAST_UPDATED', t('Last Updated'));
define('TPT_LABEL_TITLE', t('Title'));
define('TPT_LABEL_FIELD_MACHINE', t('Field Name'));
define('TPT_LABEL_FIELD_LABEL', t('Field Label'));
define('TPT_LABEL_FIELD_TYPE', t('Field Type'));

define('TPT_BTN_DASHBOARD_GO', ' ' . t('Go') . ' ');
define('TPT_BTN_DASHBOARD_BACK', ' ' . t('Back') . ' ');
define('TPT_BTN_DASHBOARD_SEND', ' ' . t('Send for Translation') . ' ');
define('TPT_BTN_DASHBOARD_CLEAR_CHANGED_FLAG', ' ' . t('Clear "Changed" Status') . ' ');
define('TPT_BTN_DASHBOARD_CANCEL_SUBMISSION', ' ' . t('Cancel Submission') . ' ');
define('TPT_BTN_DASHBOARD_CANCEL_SELECT_DOCUMENT', ' ' . t('Cancel Selected Documents') . ' ');
define('TPT_BTN_DASHBOARD_CLEAR_CANCELLED_DOCUMENTS', ' ' . t('Clear Cancelled Documents') . ' ');
define('TPT_BTN_DASHBOARD_UPDATE_SELECTED', ' ' . t('Update Selected') . ' ');
define('TPT_BTN_DASHBOARD_UPDATE_ALL', ' ' . t('Update All') . ' ');
define('TPT_BTN_DASHBOARD_SAVE', ' ' . t('Save') . ' ');
define('TPT_BTN_DASHBOARD_CLEAR_DELETED_RECORDS', ' ' . t('Clear Deleted Records') . ' ');
define('TPT_BTN_DASHBOARD_REFRESH', ' ' . t('Refresh Page') . ' ');
define('TPT_BTN_DASHBOARD_FILTER', ' ' . t('Filter') . ' ');
define('TPT_BTN_DASHBOARD_RESET', ' ' . t('Reset') . ' ');
define('TPT_BTN_DASHBOARD_ARCHIVE', ' ' . t('Archive Records') . ' ');
define('TPT_BTN_ADD', ' ' . t('Add') . ' ');
define('TPT_BTN_LOCALE_DELETE', ' ' . t('Delete') . ' ');
define('TPT_BTN_SETTINGS_PD', ' ' . t('Save PD Settings') . ' ');
define('TPT_BTN_SETTINGS_TEST_PD', ' ' . t('Test PD Connectivity') . ' ');
define('TPT_BTN_SETTINGS_SAVE_TEST_PD', ' ' . t('Save and Test Settings') . ' ');
define('TPT_BTN_SETTINGS_GENERAL', ' ' . t('Save Adaptor Settings') . ' ');
define('TPT_BTN_FIELD_UPDATE', ' ' . t('Update') . ' ');

define('TPT_PAGER_LIMIT', variable_get('transperfect_pager_limit', 10));
define('TPT_PAGER_NUMBER', 0);

define('TPT_DASHBOARD_FILTER_TYPE_BY_STATUS', 'status');
define('TPT_DASHBOARD_FILTER_TYPE_BY_TITLE', 'title');
define('TPT_DASHBOARD_FILTER_TYPE_BY_CONTENT_TYPE', 'type');
define('TPT_DASHBOARD_FILTER_TYPE_BY_TARGET_LANG', 'target');

define('TPT_TABLE_LOCALE', 'transperfect_locale');
define('TPT_TABLE_CORE', 'transperfect_core');

define('TPT_LOGGING_CONFIG_DISABLED', '0');
define('TPT_LOGGING_CONFIG_INFO', '1');
define('TPT_LOGGING_CONFIG_DEBUG', '2');

define('TPT_LOGGING_SEVERITY_INFO', 'Info');
define('TPT_LOGGING_SEVERITY_WARNING', 'Warning');
define('TPT_LOGGING_SEVERITY_ERROR', 'Error');
define('TPT_LOGGING_SEVERITY_DEBUG', 'Debug');

define('TPT_OBJECT_TYPE_CONTENT', 'Content');
define('TPT_OBJECT_TYPE_BLOCK', 'Block');
define('TPT_OBJECT_TYPE_FIELDABLE_PANELS', 'Fieldable_Panels_Panes');
define('TPT_OBJECT_TYPE_MENU', 'Menu');
define('TPT_OBJECT_TYPE_TAXONOMY', 'Taxonomy');
define('TPT_OBJECT_TYPE_WEBFORM', 'Webform');
define('TPT_OBJECT_TYPE_INTERFACE', 'Interface');
define('TPT_OBJECT_TYPE_GLOBALLINK', 'GlobalLink');

/**
 * Implements hook_permission().
 */
function transperfect_permission() {
  return array(
    TPT_ROLE_MANAGE_TRANSLATIONS => array('title' => TPT_ROLE_MANAGE_TRANSLATIONS),
    TPT_ROLE_DO_TRANSALTIONS => array('title' => TPT_ROLE_DO_TRANSALTIONS),
    TPT_ROLE_VIEW_TRANSLATIONS => array('title' => TPT_ROLE_VIEW_TRANSLATIONS)
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function transperfect_form_field_ui_field_delete_form_alter(&$form, &$form_state) {
  $field_name = $form['field_name']['#value'];
  $field_info = field_info_field($field_name);

  if ($field_info['type'] != 'list_boolean' && $field_info['type'] != 'image' && $field_info['type'] != 'file' && $field_info['type'] != 'taxonomy_term_reference') {
    array_unshift($form['#submit'], 'transperfect_form_field_ui_field_delete_form_submit');
  }
}

/**
 * Adds a validation handler to check for change in multilingual options.
 */
function transperfect_form_node_type_form_alter(&$form, $form_state) {
  array_unshift($form['#validate'], 'transperfect_form_node_type_form_validate');
}

/**
 * Validation to check if any active submission exists for this content type.
 * Only if there is a change in multilingual options.
 */
function transperfect_form_node_type_form_validate($form, &$form_state) {
  $language_content_type = $form_state['values']['language_content_type'];

  if ($language_content_type != 2 && transperfect_pending_submission_exists_for_content_type($form_state['values']['old_type'])) {
    form_set_error('language_content_type', 'Active submission exists for this content type in GlobalLink.');
  }
}

/**
 * Submit handler for delete link on Manage Fields Page of Content Type and Field Collection.
 * This deletes a field from fields config table.
 */
function transperfect_form_field_ui_field_delete_form_submit($form, &$form_state) {
  $entity_type = isset($form['entity_type']['#value']) ? $form['entity_type']['#value'] : FALSE;
  $bundle_name = isset($form['bundle']['#value']) ? $form['bundle']['#value'] : FALSE;
  $field_name = isset($form['field_name']['#value']) ? $form['field_name']['#value'] : FALSE;

  if (!$entity_type) {
    return;
  }

  switch ($entity_type) {
    case 'node':
      // Request coming from Manage Fields of Content Type
      $field_info = field_info_field($field_name);

      switch ($field_info['type']) {
        case 'list_boolean':
        case 'image':
        case 'file':
        case 'taxonomy_term_reference':
          break;
        case 'field_collection':
          // field-collection being deleted, delete all fields recursively for this content type only
          transperfect_delete_fc($bundle_name, $field_name, $entity_type, $bundle_name);
        default:
          // Regular field, just delete from the config
          db_delete('transperfect_field_config')
          ->condition('content_type', $bundle_name, ' = ')
          ->condition('entity_type', $entity_type, ' = ')
          ->condition('bundle', $bundle_name, ' = ')
          ->condition('field_name', $field_name, ' = ')
          ->execute();
      }

      break;
    case 'field_collection_item':
      // Request coming from Manage Fields of Field Collections
      // Entity type for all the fields here will be field_collection_item
      $field_info = field_info_field($field_name);

      switch ($field_info['type']) {
        case 'list_boolean':
        case 'image':
        case 'file':
        case 'taxonomy_term_reference':
        case 'field_collection':
          // Field-collection being deleted, delete all fields recursively for all the content types
          $content_types = transperfect_get_all_content_types_for_field($bundle_name, 'field_collection');

          foreach ($content_types as $content_type) {
            transperfect_delete_fc($content_type, $field_name, $entity_type, $bundle_name);
          }

          break;
        default:
          // Regular field-collection field, just delete from the config for all content types
          $content_types = transperfect_get_all_content_types_for_field($bundle_name, 'field_collection');

          foreach ($content_types as $content_type) {
            db_delete('transperfect_field_config')
            ->condition('content_type', $content_type, ' = ')
            ->condition('entity_type', $entity_type, ' = ')
            ->condition('bundle', $bundle_name, ' = ')
            ->condition('field_name', $field_name, ' = ')
            ->execute();
          }
      }

      break;
  }
}

/**
 * Determines whether or not the translation is supported.
 *
 * @param string $type
 *   The type of translation.
 *
 * @return bool
 *   True if the translation is supported.
 */
function transperfect_translation_supported($type) {
  if (translation_supported_type($type) || (module_exists('transperfect_entity') && entity_translation_node_supported_type($type))) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Removes an existing field-collection field from field config.
 *
 * @param string $content_type
 *   The node content type.
 * @param string $fc_name
 *   The field-collection field name.
 * @param string $entity_type
 *   The field entity type.
 * @param string $bundle
 *   The field bundle name.
 */
function transperfect_delete_fc($content_type, $fc_name, $entity_type, $bundle) {
  db_delete('transperfect_field_config')
  ->condition('content_type', $content_type, ' = ')
  ->condition('entity_type', $entity_type, ' = ')
  ->condition('bundle', $bundle, ' = ')
  ->condition('field_name', $fc_name, ' = ')
  ->execute();

  $fc_field_infos = field_info_instances('field_collection_item');

  if (isset($fc_field_infos) && isset($fc_field_infos[$fc_name]) && is_array($fc_field_infos[$fc_name])) {
    $fc_items = array_keys($fc_field_infos[$fc_name]);

    foreach ($fc_items as $fc_item) {
      // All field collection items have entity type as field_collection_item
      transperfect_delete_fc_items($content_type, $fc_name, $fc_item, 'field_collection_item');
    }
  }
}

/**
 * Removes an existing child field of field-collection from field config.
 *
 * @param string $content_type
 *   The node content type.
 * @param string $parent_field_name
 *   The field-collection parent name.
 * @param string $field_name
 *   The field name.
 * @param string $entity_type
 *   The field entity type.
 */
function transperfect_delete_fc_items($content_type, $parent_field_name, $field_name, $entity_type) {
  $fc_field_info = field_info_field($field_name);

  switch ($fc_field_info['type']) {
    case 'list_boolean':
    case 'image':
    case 'file':
    case 'taxonomy_term_reference':
      break;
    case 'field_collection':
      // First delete the field-collection field
      db_delete('transperfect_field_config')
      ->condition('content_type', $content_type, ' = ')
      ->condition('entity_type', $entity_type, ' = ')
      ->condition('bundle', $parent_field_name, ' = ')
      ->condition('field_name', $field_name, ' = ')
      ->execute();

      $fc_field_infos = field_info_instances('field_collection_item');

      if (isset($fc_field_infos) && isset($fc_field_infos[$field_name]) && is_array($fc_field_infos[$field_name])) {
        $fc_items = array_keys($fc_field_infos[$field_name]);
        foreach ($fc_items as $fc_item) {
          // Delete all child fields recursively
          transperfect_delete_fc_items($content_type, $field_name, $fc_item, $entity_type);
        }
      }

      break;
    default:
      // Regular field-collection field, just delete from config
      db_delete('transperfect_field_config')
      ->condition('content_type', $content_type, ' = ')
      ->condition('entity_type', $entity_type, ' = ')
      ->condition('bundle', $parent_field_name, ' = ')
      ->condition('field_name', $field_name, ' = ')
      ->execute();
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function transperfect_form_field_ui_field_overview_form_alter(&$form, &$form_state) {
  $form['#submit'][] = 'transperfect_form_field_ui_field_overview_form_submit';
}

/**
 * Submit handler for Manage Fields Page of Content Type and Field Collection.
 * Adds a new field being added to the fields config table for translation.
 */
function transperfect_form_field_ui_field_overview_form_submit(&$form, &$form_state) {
  $entity_type = isset($form['#entity_type']) ? $form['#entity_type'] : FALSE;
  $bundle = isset($form['#bundle']) ? $form['#bundle'] : FALSE;
  $new_field = isset($form['fields']['_add_new_field']) ? $form['fields']['_add_new_field'] : FALSE;
  $existing_field = isset($form['fields']['_add_existing_field']) ? $form['fields']['_add_existing_field'] : FALSE;

  if (!$entity_type) {
    return;
  }

  switch ($entity_type) {
    case 'node':
      if (!transperfect_translation_supported($bundle)) {
        break;
      }

      // Request coming from Manage Fields of Content Type
      if ($new_field && isset($new_field['type']['#value'])) {
        switch ($new_field['type']['#value']) {
          case 'list_boolean':
          case 'image':
          case 'file':
          case 'taxonomy_term_reference':
            break;
          case 'field_collection':
            // New field-collection added, just add the empty field-collection to config
            $new_field_name = $new_field['field_name']['#value'];

            if ($new_field_name != '') {
              db_insert('transperfect_field_config')
              ->fields(array(
                'content_type' => $bundle,
                'entity_type' => $entity_type,
                'bundle' => $bundle,
                'field_name' => 'field_' . $new_field_name,
                'field_type' => $new_field['type']['#value'],
                'field_label' => $new_field['label']['#value'],
                'translatable' => 1,
              ))->execute();
            }

            break;
          default:
            // Regular New field, just add to config
            $new_field_name = $new_field['field_name']['#value'];

            if ($new_field_name != '') {
              db_insert('transperfect_field_config')
              ->fields(array(
                'content_type' => $bundle,
                'entity_type' => $entity_type,
                'bundle' => $bundle,
                'field_name' => 'field_' . $new_field_name,
                'field_type' => $new_field['type']['#value'],
                'field_label' => $new_field['label']['#value'],
                'translatable' => 1,
              ))->execute();
            }
        }
      }

      if ($existing_field && isset($existing_field['field_name']['#value'])) {
        // Existing field is being added to this content type
        $existing_field_name = $existing_field['field_name']['#value'];

        if ($existing_field_name != '') {
          $existing_field_info = field_info_field($existing_field_name);

          switch ($existing_field_info['type']) {
            case 'list_boolean':
            case 'image':
            case 'file':
            case 'taxonomy_term_reference':
              break;
            case 'field_collection':
              // Existing FC being added to this content type
              // Add FC and all the FC fields recursively to the config
              transperfect_insert_fc($entity_type, $existing_field_name, $bundle, $bundle);

              break;
            default:
              // Regular existing field, just add to config
              $existing_field_instance = field_info_instance($entity_type, $existing_field_name, $bundle);

              db_insert('transperfect_field_config')
              ->fields(array(
                'content_type' => $bundle,
                'entity_type' => $entity_type,
                'bundle' => $bundle,
                'field_name' => $existing_field_name,
                'field_type' => $existing_field_info['type'],
                'field_label' => $existing_field_instance['label'],
                'translatable' => 1,
              ))->execute();

              break;
          }
        }
      }

      break;
    case 'field_collection_item':
      // Request coming from Manage Fields of Field Collections
      // Entity type for all the fields here will be field_collection_item
      $fc_name = $bundle;

      if ($new_field && isset($new_field['type']['#value'])) {
        // A new field is being added to this field-collection
        if ($new_field['type']['#value'] != 'list_boolean'
                && $new_field['type']['#value'] != 'image'
                && $new_field['type']['#value'] != 'file'
                && $new_field['type']['#value'] != 'taxonomy_term_reference') {
          // Regular new field is being added to this field-collection, just add to config
          $new_field_name = $new_field['field_name']['#value'];
          if ($new_field_name != '') {
            // First get all the content types for this field-collection from config,
            // then add this field for all the content types in the config
            $content_types = transperfect_get_all_content_types_for_field($fc_name, 'field_collection');
            foreach ($content_types as $content_type) {
              db_insert('transperfect_field_config')
                      ->fields(array('content_type' => $content_type,
                          'entity_type' => $entity_type,
                          'bundle' => $fc_name,
                          'field_name' => 'field_' . $new_field_name,
                          'field_type' => $new_field['type']['#value'],
                          'field_label' => $new_field['label']['#value'],
                          'translatable' => 1))->execute();
            }
          }
        }
      }
      if ($existing_field && isset($existing_field['field_name']['#value'])) {
        // Existing field is being added to this field-collection
        $existing_field_name = $existing_field['field_name']['#value'];
        if ($existing_field_name != '') {
          $existing_field_info = field_info_field($existing_field_name);

          switch ($existing_field_info['type']) {
            case 'list_boolean':
            case 'image':
            case 'file':
            case 'taxonomy_term_reference':
              break;
            case 'field_collection':
              // If existing field-collection is added to the field-collection, then add fields recursively
              $content_types = transperfect_get_all_content_types_for_field($fc_name, 'field_collection');
              // First get all the content types for this field-collection from config
              // then add this field for all the content types in the config
              foreach ($content_types as $content_type) {
                transperfect_insert_fc($entity_type, $existing_field_name, $content_type, $fc_name);
              }
            default:
              // First get all the content types for this field-collection from config
              // then add this field for all the content types in the config
              $content_types = transperfect_get_all_content_types_for_field($fc_name, 'field_collection');

              foreach ($content_types as $content_type) {
                $existing_field_instance = field_info_instance($entity_type, $existing_field_name, $bundle);
                db_insert('transperfect_field_config')
                ->fields(array(
                  'content_type' => $content_type,
                  'entity_type' => $entity_type,
                  'bundle' => $fc_name,
                  'field_name' => $existing_field_name,
                  'field_type' => $existing_field_info['type'],
                  'field_label' => $existing_field_instance['label'],
                  'translatable' => 1,
                ))->execute();
              }
          }
        }
      }

      break;
  }
}

/**
 * Adds field-collection field to field config.
 *
 * @param string $entity_type
 *   The field entity type.
 * @param string $fc_name
 *   The field-collection name.
 * @param string $content_type
 *   The node content type.
 * @param string $bundle
 *   The field bundle name.
 */
function transperfect_insert_fc($entity_type, $fc_name, $content_type, $bundle) {
  $fc_field_info = field_info_field($fc_name);
  $fc_field_instance = field_info_instance($entity_type, $fc_name, $bundle);
  // Add FC field to the config
  db_insert('transperfect_field_config')
  ->fields(array(
    'content_type' => $content_type,
    'entity_type' => $entity_type,
    'bundle' => $bundle,
    'field_name' => $fc_name,
    'field_type' => $fc_field_info['type'],
    'field_label' => $fc_field_instance['label'],
    'translatable' => 0
  ))->execute();

  $fc_field_infos = field_info_instances('field_collection_item');

  if (isset($fc_field_infos) && isset($fc_field_infos[$fc_name]) && is_array($fc_field_infos[$fc_name])) {
    $fc_items = array_keys($fc_field_infos[$fc_name]);

    foreach ($fc_items as $fc_item) {
      // Add all the FC field items recursively
      transperfect_insert_fc_items($content_type, $fc_name, $fc_item);
    }
  }
}

/**
 * Adds child field of field-collection to field config.
 *
 * @param string $content_type
 *   The node content type.
 * @param string $parent_field_name
 *   The parent field-collection name.
 * @param string $field_name
 *   The field name.
 */
function transperfect_insert_fc_items($content_type, $parent_field_name, $field_name) {
  // Everything added here will have entity type as field_collection_item
  $fc_field_info = field_info_field($field_name);
  $fc_field_instance = field_info_instance('field_collection_item', $field_name, $parent_field_name);

  switch ($fc_field_info['type']) {
    case 'image':
    case 'file':
    case 'taxonomy_term_reference':
      break;
    case 'field_collection':
      // Field-collection in a field-collection, first add this field-collection to the config
      db_insert('transperfect_field_config')
      ->fields(array(
        'content_type' => $content_type,
        'entity_type' => 'field_collection_item',
        'bundle' => $parent_field_name,
        'field_name' => $field_name,
        'field_type' => $fc_field_info['type'],
        'field_label' => $fc_field_instance['label'],
        'translatable' => 0,
      ))->execute();

      $fc_field_infos = field_info_instances('field_collection_item');

      if (isset($fc_field_infos) && isset($fc_field_infos[$field_name]) && is_array($fc_field_infos[$field_name])) {
        $fc_items = array_keys($fc_field_infos[$field_name]);

        foreach ($fc_items as $fc_item) {
          // Now add the child fields for this field-collection recursively
          transperfect_insert_fc_items($content_type, $field_name, $fc_item);
        }
      }

      break;
    default:
      $translatable = 1;

      db_insert('transperfect_field_config')
      ->fields(array(
        'content_type' => $content_type,
        'entity_type' => 'field_collection_item',
        'bundle' => $parent_field_name,
        'field_name' => $field_name,
        'field_type' => $fc_field_info['type'],
        'field_label' => $fc_field_instance['label'],
        'translatable' => $translatable,
      ))->execute();
  }
}

/**
 * Gets all content types for a specified field.
 *
 * @param string $field_name
 *   The name of the field to search.
 * @param string $type
 *   The field's type.
 *
 * @return array
 *   An array containing all content types for the specified field.
 */
function transperfect_get_all_content_types_for_field($field_name, $type) {
  $array = array();

  $result = db_select('transperfect_field_config', 'tf')
  ->fields('tf', array('content_type'))
  ->distinct()
  ->condition('field_name', $field_name, '=')
  ->condition('field_type', $type, '=')
  ->execute();

  foreach ($result as $row) {
    $array[] = $row->content_type;
  }

  return $array;
}

/**
 * Implements hook_node_type_insert().
 */
function transperfect_node_type_insert($info) {
  if (transperfect_translation_supported($info->type)) {
    db_insert('transperfect_field_config')
    ->fields(array(
      'content_type' => $info->type,
      'entity_type' => 'node',
      'bundle' => $info->type,
      'field_name' => 'title',
      'field_type' => 'text',
      'field_label' => 'Title',
      'translatable' => 1,
    ))->execute();

    db_insert('transperfect_field_config')
    ->fields(array(
      'content_type' => $info->type,
      'entity_type' => 'node',
      'bundle' => $info->type,
      'field_name' => 'body',
      'field_type' => 'text_with_summary',
      'field_label' => 'Body',
      'translatable' => 1,
    ))->execute();

    $metatag_module_exists = module_exists("metatag");

    if ($metatag_module_exists) {
      db_insert('transperfect_field_config')
      ->fields(array(
        'content_type' => $info->type,
        'entity_type' => 'node',
        'bundle' => $info->type,
        'field_name' => 'metatags',
        'field_type' => 'text',
        'field_label' => 'Meta tags',
        'translatable' => 1,
      ))->execute();
    }
  }
}

/**
 * Implements hook_node_type_update().
 */
function transperfect_node_type_update($info) {
  if ($info->modified) {
    if (count(transperfect_get_translatable_fields($info->old_type)) > 0) {
      if (transperfect_translation_supported($info->type)) {
        db_update('transperfect_field_config')
        ->fields(array('content_type' => $info->orig_type))
        ->condition('content_type', $info->old_type, '=')
        ->execute();

        db_update('transperfect_field_config')
        ->fields(array('bundle' => $info->orig_type))
        ->condition('bundle', $info->old_type, '=')
        ->execute();

        db_update('transperfect_core')
        ->fields(array('type' => $info->orig_type))
        ->condition('type', $info->old_type, '=')
        ->execute();
      }
      else {
        delete_field_configs($info->type);
      }
    }
    else {
      if (transperfect_translation_supported($info->type)) {
        transperfect_insert_all_fields($info->type);
      }
    }
  }
}

/**
 * Adds all fields of content type to field config.
 *
 * @param string $content_type
 *   The node content type.
 */
function transperfect_insert_all_fields($content_type) {
  $p_arr = transperfect_get_pending_fields($content_type);
  $f_keys = array_keys($p_arr);

  foreach ($f_keys as $f_key) {
    if ($f_key == '[all]') {
      continue;
    }

    if ($f_key != 'title' && $f_key != 'metatags') {
      $field = field_info_field($f_key);

      if ($field['type'] != 'list_boolean' && $field['type'] != 'image' && $field['type'] != 'file' && $field['type'] != 'taxonomy_term_reference' && $field['type'] != 'field_collection') {
        db_insert('transperfect_field_config')
        ->fields(array(
          'content_type' => $content_type,
          'entity_type' => 'node',
          'bundle' => $content_type,
          'field_name' => $f_key,
          'field_type' => $field['type'],
          'field_label' => $p_arr[$f_key],
          'translatable' => 1,
        ))->execute();
      }
    }
    else {
      db_insert('transperfect_field_config')
      ->fields(array(
        'content_type' => $content_type,
        'entity_type' => 'node',
        'bundle' => $content_type,
        'field_name' => $f_key,
        'field_type' => 'text',
        'field_label' => $p_arr[$f_key],
        'translatable' => 1,
      ))->execute();
    }
  }

  if (module_exists('field_collection')) {
    transperfect_insert_fc_fields($content_type);
  }
}

/**
 * Removes all fields for content type from field config.
 *
 * @param string $type
 *   The node content type.
 */
function delete_field_configs($type) {
  db_delete('transperfect_field_config')
  ->condition('content_type', $type, ' = ')
  ->execute();
}

/**
 * Implements hook_node_type_delete().
 */
function transperfect_node_type_delete($info) {
  delete_field_configs($info->type);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function transperfect_form_field_ui_field_edit_form_alter(&$form, $form_state) {
  $field_type = $form['#field']['type'];

  if ($field_type != 'list_boolean' && $field_type != 'image' && $field_type != 'file' && $field_type != 'taxonomy_term_reference' && $field_type != 'field_collection') {
    $field_name = $form['#field']['field_name'];
    $entity_type = $form['#instance']['entity_type'];
    $bundle_name = $form['#instance']['bundle'];

    if ($entity_type != 'field_collection_item') {
      if (transperfect_translation_supported($bundle_name)) {
        $translatable = transperfect_is_field_configured_for_translation($entity_type, $bundle_name, $field_name, $bundle_name);
        $label = t('GlobalLink Translation');
        $title = t('This field can be translated using Translations.com translation services.');

        $form['instance']['transperfect_translate_field'] = array(
          '#prefix' => '<label>' . $label . '</label>',
          '#type' => 'checkbox',
          '#title' => $title,
          '#default_value' => $translatable ? 1 : 0,
        );
      }
    }
  }

  $form['#submit'][] = 'transperfect_form_field_ui_field_edit_form_submit';
}

/**
 * Update field config for modified bundle field.
 */
function transperfect_form_field_ui_field_edit_form_submit($form, &$form_state) {
  $field_name = $form['#instance']['field_name'];
  $entity_type = $form['#instance']['entity_type'];
  $bundle_name = $form['#instance']['bundle'];

  if (transperfect_check_field_configured($bundle_name, $entity_type, $bundle_name, $field_name)) {
    if ($entity_type == 'node') {
      if (transperfect_translation_supported($bundle_name)) {
        if (isset($form['instance']['transperfect_translate_field'])) {
          $translatable = $form['instance']['transperfect_translate_field']['#value'];

          db_update('transperfect_field_config')
          ->fields(array(
            'field_label' => $form['instance']['label']['#value'],
            'translatable' => $translatable,
          ))
          ->condition('content_type', $bundle_name, '=')
          ->condition('entity_type', $entity_type, '=')
          ->condition('bundle', $bundle_name, '=')
          ->condition('field_name', $field_name, '=')
          ->execute();
        }
      }
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function transperfect_node_presave($node) {
  if (isset($node->tpt_skip) && $node->tpt_skip == TRUE) {
    return;
  }
  if (!transperfect_translation_supported($node->type)) {
    return;
  }
  if (!isset($node->original)) {
    return;
  }

  $handler = entity_translation_get_handler("node", $node);
  $config_fields = transperfect_get_translatable_fields($node->type, $node->type);
  $orig = $node->original;
  $lang = $handler->getFormLanguage(); // language of the node

  foreach ($config_fields as $field) {
    if ($field->translatable != 1) {
      continue;
    }

    $field_name = $field->field_name;

    switch ($field_name) {
      case 'title':
        if ($orig->title != $node->title) {
          transperfect_update_change_detection($node, $lang);

          break 2;
        }

        break 1;
      case 'metatags':
        continue 2;

        break 1;
    }

    $field_info = field_info_field($field_name);

    if ($field_info['type'] == 'list_boolean' && $field_info['type'] == 'image' && $field_info['type'] == 'file' && $field_info['type'] == 'taxonomy_term_reference' && $field_info['type'] == 'field_collection') {
      continue;
    }

    if (isset($node->$field_name) && isset($orig->$field_name)) {
      $o_arr = $orig->$field_name;
      $n_arr = $node->$field_name;

      if (isset($o_arr) && isset($n_arr) && count($o_arr) == count($n_arr)) {
        if (is_array($o_arr) && is_array($n_arr)) {
          if (isset($o_arr) && isset($o_arr[$lang]) && count($o_arr[$lang]) == count($n_arr)) {
            if (isset($o_arr[$lang]) && isset($n_arr[$lang])) {
              if (count($o_arr[$lang]) == count($n_arr[$lang])) {
                foreach ($o_arr[$lang] as $delta => $n_field) {
                  if (isset($n_arr[$lang][$delta]) && isset($n_arr[$lang][$delta]['value'])) {
                    if ($n_field['value'] != $n_arr[$lang][$delta]['value']) {
                      transperfect_update_change_detection($node, $lang);

                      break 2;
                    }
                  }
                  else {
                    transperfect_update_change_detection($node, $lang);

                    break 2;
                  }
                }
              }
              else {
                transperfect_update_change_detection($node, $lang);

                break;
              }
            }
            else {
              transperfect_update_change_detection($node, $lang);

              break;
            }
          }
          else {
            transperfect_update_change_detection($node, $lang);

            break;
          }
        }
        else {
          if ($o_arr != $n_arr) {
            transperfect_update_change_detection($node, $lang);

            break;
          }
        }
      }
      else {
        transperfect_update_change_detection($node, $lang);

        break;
      }
    }
    else {
      transperfect_update_change_detection($node, $lang);

      break;
    }
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function transperfect_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  $node_check = variable_get('transperfect_implementation_type', 0);

  if ($root_path == 'node/%/translate') {
    if ((preg_match("!^node/(\d+)(/.+|)$!", $router_item['href'], $matches)) && ($node = node_load((int) $matches[1]))) {
      $nid = $node->tnid;

      if ($node->tnid == 0) {
        $nid = $node->nid;
      }

      if (translation_supported_type($node->type)) {
        $send_link = transperfect_get_root_menu('transperfect-translations/dashboard');
        $active_link = transperfect_get_root_menu('transperfect-translations/activeSubmissions');
      }
      elseif (entity_translation_node_supported_type($node->type)) {
        $send_link = transperfect_get_root_menu('transperfect-translations/dashboard/entity');
        $active_link = transperfect_get_root_menu('transperfect-translations/activeSubmissions/entity');
      }
      else {
        return;
      }

      if ($node_check == 1) {
        if (!transperfect_tpt_is_node_translatable(node_load($nid))) {
          return;
        }
      }

      $pending = TRUE;
      $source = language_default()->language;
      $t_nodes = translation_node_get_translations($nid);

      if (count($t_nodes) > 0) {
        if (isset($t_nodes[$source])) {
          unset($t_nodes[$source]);
          $langs = language_list();
          unset($langs[$source]);

          if (count($langs) > 0) {
            $tgt_arr = transperfect_get_tpt_sent_rows($nid, $source);
            $tpt_count = count($tgt_arr);

            if ($tpt_count > 0 && $tpt_count == count($langs)) {
              $pending = FALSE;
            }
          }
        }
      }

      $data['actions']['output']['transperfect'] = array(
        '#theme' => 'menu_local_action',
        '#link' => array(),
      );

      if ($pending) {
        if (user_access(TPT_ROLE_MANAGE_TRANSLATIONS) || user_access(TPT_ROLE_DO_TRANSALTIONS)) {
          $data['actions']['output']['transperfect']['#link']['title'] = t('Send for translation');
          $data['actions']['output']['transperfect']['#link']['href'] = $send_link;
          $data['actions']['output']['transperfect']['#link']['localized_options'] = array('query' => array('rnid' => $nid));
        }
      }
      else {
        $data['actions']['output']['transperfect']['#link']['title'] = t('This content has been sent out for translation.');
        $data['actions']['output']['transperfect']['#link']['href'] = $active_link;
        $data['actions']['output']['transperfect']['#link']['localized_options'] = array('query' => array('rnid' => $nid));
      }
    }
  }
}

/**
 * Retrieve languages with in progress translations.
 *
 * @param int $nid
 *   The node id.
 * @param string $source
 *   The drupal locale code.
 *
 * @return array
 *   An array containing all drupal locale codes with in progress translations.
 */
function transperfect_get_tpt_sent_rows($nid, $source) {
  $arr = array();

  $query = db_select('transperfect_core', 'tc')
  ->fields('tc')
  ->condition('nid', $nid, '=')
  ->condition('status', array(TPT_STATUS_SENT_FOR_TRANSLATIONS, TPT_STATUS_ERROR, TPT_STATUS_CANCELLED), 'IN')
          ->condition('source', transperfect_get_locale_code($source), '=');
  $result = $query->execute();

  foreach ($result as $row) {
    $arr[] = transperfect_get_drupal_locale_code($row->target);
  }

  return $arr;
}

/**
 * Update row to flag that node has been modified.
 *
 * @param object $node
 *   The node object.
 * @param string $lang
 *   The locale of the node.
 */
function transperfect_update_change_detection($node, $lang) {
  $tpt_locale_code = transperfect_get_locale_code($lang);
  db_update('transperfect_core')
  ->fields(array('last_modified' => REQUEST_TIME, 'changed' => 1))
  ->condition('nid', $node->nid, '=')
  ->condition('source', $tpt_locale_code, '=')
  ->execute();
}

/**
 * Gets translatable fields.
 *
 * @param string $type
 *   The fields' content type.
 * @param bool $bundle
 *   The field bundle name.  Defaults to false.
 *
 * @return array
 *   An array containing all fields of the specified type that are translatable.
 */
function transperfect_get_translatable_fields($type, $bundle = FALSE) {
  $fields = array();

  if ($bundle) {
    $result = db_select('transperfect_field_config', 'tfc')
    ->fields('tfc')
    ->condition('content_type', $type, '=')
    ->condition('bundle', $bundle, '=')
    ->execute();
  }
  else {
    $result = db_select('transperfect_field_config', 'tfc')
    ->fields('tfc')
    ->condition('content_type', $type, '=')
    ->execute();
  }

  foreach ($result as $row) {
    $fields[] = $row;
  }

  return $fields;
}

/**
 * Checks if a field is configured.
 *
 * @param string $content_type
 *   The field's content type.
 * @param string $entity_type
 *   The field's entity type.
 * @param bool $bundle
 *   The field bundle name.
 * @param string $field_name
 *   The name of the field.
 *
 * @return bool
 *   True if the field is configured, and false if it isn't.
 */
function transperfect_check_field_configured($content_type, $entity_type, $bundle, $field_name) {
  $result = db_select('transperfect_field_config', 'tfc')
  ->fields('tfc')
  ->condition('content_type', $content_type, '=')
  ->condition('entity_type', $entity_type, '=')
  ->condition('bundle', $bundle, '=')
  ->condition('field_name', $field_name, '=')
  ->execute();

  foreach ($result as $row) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_menu().
 */
function transperfect_menu() {
  $items = array();

  $items [transperfect_get_root_menu('transperfect-translations')] = array(
    'title' => 'GlobalLink',
    'description' => 'Allows users to manage and translate content using Translations.com translation services',
    'page callback' => 'transperfect_dashboard_page',
      'access callback' => 'transperfect_access_callback_any',
    'file' => 'transperfect_send_translations.inc',
    'page arguments' => array('node'),
  );

  $items [transperfect_get_root_menu('transperfect-translations/dashboard')] = array(
    'title' => 'Send For Translation',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
    'page arguments' => array('node'),
  );

  $items [transperfect_get_root_menu('transperfect-translations/dashboard/node')] = array(
    'title' => ' Content ',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -5,
    'page arguments' => array('node'),
  );

  $items [transperfect_get_root_menu('transperfect-translations/activeSubmissions')] = array(
    'title' => 'Active Submissions',
    'description' => 'Presents a Dashboard interface to view active submissions',
    'page callback' => 'transperfect_dashboard_active_submissions_page',
      'access callback' => 'transperfect_access_callback_any',
    'file' => 'transperfect_active_submissions.inc',
    'weight' => -1,
    'type' => MENU_LOCAL_TASK,
    'page arguments' => array('node'),
  );

  $items [transperfect_get_root_menu('transperfect-translations/activeSubmissions/node')] = array(
    'title' => ' Content ',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'page arguments' => array('node'),
      'access callback' => 'transperfect_access_callback_any',
  );

  $items [transperfect_get_root_menu('transperfect-translations/receiveTranslation')] = array(
    'title' => 'Receive Translation',
    'description' => 'Presents a Dashboard interface to receive and publish translations',
    'page callback' => 'transperfect_dashboard_receive_page',
      'access callback' => 'transperfect_access_callback_any',
    'type' => MENU_LOCAL_TASK,
    'file' => 'transperfect_receive_translations.inc',
    'weight' => -1,
    'page arguments' => array('node'),
  );

  $items [transperfect_get_root_menu('transperfect-translations/receiveTranslation/node')] = array(
    'title' => ' Content ',
      'access callback' => 'transperfect_access_callback_any',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'page arguments' => array('node'),
  );

  $items [transperfect_get_root_menu('transperfect-translations/settings')] = array(
    'title' => 'Settings',
    'description' => 'Manage settings for GlobalLink',
    'page callback' => 'transperfect_settings_page',
      'access arguments' => array(TPT_ROLE_MANAGE_TRANSLATIONS),
    'type' => MENU_LOCAL_TASK,
    'file' => 'transperfect_settings.inc',
  );

  $items [transperfect_get_root_menu('transperfect-translations/locale')] = array(
    'title' => 'Locale Mapping',
    'description' => 'Manage locale mappings for GlobalLink',
    'page callback' => 'transperfect_locale_page',
      'access arguments' => array(TPT_ROLE_MANAGE_TRANSLATIONS),
    'type' => MENU_LOCAL_TASK,
    'file' => 'transperfect_locale_mapping.inc',
  );
  $items [transperfect_get_root_menu('transperfect-translations/fieldConfig')] = array(
    'title' => 'Field Configuration',
    'description' => 'Manage translatable fields for content types',
    'page callback' => 'transperfect_field_page',
      'access arguments' => array(TPT_ROLE_MANAGE_TRANSLATIONS),
    'type' => MENU_LOCAL_TASK,
    'file' => 'transperfect_field_configuration.inc',
  );
  $items[transperfect_get_root_menu('transperfect-translations/cron')] = array(
    'title' => 'Receive Translations Cron',
      'page callback' => 'transperfect_receive_translated_contents_automatically',
    'file' => 'transperfect_receive_translations.inc',
      'access arguments' => array(TPT_ROLE_MANAGE_TRANSLATIONS),
    'type' => MENU_CALLBACK,
  );
  $items[transperfect_get_root_menu('transperfect-translations/preview')] = array(
    'title' => 'Preview Translation',
      'page callback' => 'transperfect_preview_translated_content',
    'file' => 'transperfect_receive_translations.inc',
      'access arguments' => array(TPT_ROLE_MANAGE_TRANSLATIONS),
    'type' => MENU_CALLBACK,
  );
  $items[transperfect_get_root_menu('transperfect-translations/view_log')] = array(
    'title' => 'View Log',
      'page callback' => 'transperfect_view_log',
    'file' => 'transperfect_settings.inc',
      'access arguments' => array(TPT_ROLE_MANAGE_TRANSLATIONS),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * @todo Document this function.
 */
function transperfect_access_callback_any() {
  return user_access(TPT_ROLE_MANAGE_TRANSLATIONS) || user_access(TPT_ROLE_DO_TRANSALTIONS) || user_access(TPT_ROLE_VIEW_TRANSLATIONS);
}

/**
 * Implements hook_cron().
 */
function transperfect_cron() {
  // Only run this if settings are set to Drupal Cron.
  if (!variable_get('transperfect_cron_type', 0)) {
    return;
  }

  // Create Drupal queue item.
  $queue = DrupalQueue::get('auto_receive');
  $queue->createItem('hook_cron');
}

/**
 * Implements hook_cron_queue_info().
 */
function transperfect_cron_queue_info() {
  $queues['auto_receive'] = array(
    'worker callback' => 'transperfect_auto_receive',
  );
}

/*
 * Implements hook_transperfect_is_node_translatable().
 */
function transperfect_tpt_is_node_translatable($node, $drupal_target_locale = NULL) {
  $result = module_invoke_all('transperfect_is_node_translatable', $node, $drupal_target_locale);

  if (count($result) > 0) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_transperfect_is_field_translatable().
 */
function transperfect_tpt_is_field_translatable($node, $field, $drupal_target_locale = NULL) {
  $result = module_invoke_all('transperfect_is_field_translatable', $node, $field, $drupal_target_locale);

  if (count($result) > 0) {
    return TRUE;
  }

  return FALSE;
}

/*
 * Implements hook_transperfect_translate_node_for_language().
 */
function transperfect_tpt_translate_node_for_language($node, $drupal_target_locale) {
  $result = module_invoke_all('transperfect_translate_node_for_language', $node, $drupal_target_locale);

  if (count($result) > 0) {
    return TRUE;
  }

  return FALSE;
}

/*
 * Implements hook_transperfect_import_translation().
 */
function transperfect_tpt_update_node($source_node, $target_node) {
  foreach (module_implements('transperfect_import_translation') as $module) {
    $function = $module . '_transperfect_import_translation';
    $function($source_node->nid, $target_node);
  }
}
